# Bestell Bot Voice - Cursor Rules

## Projektübersicht

Ein Voice-Bot für telefonische Bestellungen bei Heinrich Schmidt (SHK-Fachgroßhandel). Der Server empfängt Telefonanrufe via SIP, verarbeitet Sprache mit OpenAI Realtime API und ermöglicht Produktsuche sowie Bestellverwaltung über einen Multi-Hersteller Katalog mit über 86.000 Produkten von 63 Herstellern.

## Architektur

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           LINUX SERVER (Docker)                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    FastAPI Backend (Port 8085)                   │   │
│  │  ┌───────────────┐   ┌────────────────┐   ┌──────────────────┐  │   │
│  │  │  SIP Client   │   │   AI Client    │   │  Order Manager   │  │   │
│  │  │   (PJSIP)     │◄─►│ (OpenAI WS)    │◄─►│                  │  │   │
│  │  └───────┬───────┘   └───────┬────────┘   └──────────────────┘  │   │
│  │          │                   │                                   │   │
│  │          │ Audio 48kHz       │ Audio 16kHz/24kHz                 │   │
│  │          ▼                   ▼                                   │   │
│  │  ┌──────────────────────────────────────────────────────────┐   │   │
│  │  │              Audio Resampling Pipeline                    │   │   │
│  │  │   Caller (48kHz) ─resample─► AI (16kHz)                  │   │   │
│  │  │   AI (24kHz) ─resample─► Caller (48kHz)                  │   │   │
│  │  └──────────────────────────────────────────────────────────┘   │   │
│  │                                                                   │   │
│  │  ┌──────────────────────────────────────────────────────────┐   │   │
│  │  │              Katalog System (Multi-Hersteller)            │   │   │
│  │  │   63 Hersteller │ 86.000+ Produkte │ Dynamisches Laden   │   │   │
│  │  └──────────────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Ports: 5060/UDP (SIP), 4000-4100/UDP (RTP), 8085/TCP (API)            │
└─────────────────────────────────────────────────────────────────────────┘
          │
          │ WebSocket + REST API
          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                     REMOTE GUI (PySide6 Desktop App)                    │
│                                                                         │
│  - Verbindet zu http://SERVER_IP:8085                                   │
│  - WebSocket für Live-Updates (Transkripte, Call-Events, Bestellungen) │
│  - REST API für Steuerung (Hangup, Mute, Instructions, Model)          │
└─────────────────────────────────────────────────────────────────────────┘
```

## Projektstruktur

```
Bestell Bot Voice/
├── .cursorrules          # Diese Datei - Architektur-Dokumentation
├── findings.md           # Troubleshooting-Wissen (WICHTIG!)
├── README.md
│
├── gui/                  # Remote-GUI (PySide6)
│   ├── main.py           # Hauptanwendung, verbindet zu Server
│   └── instructions.json # Lokale Kopie der AI-Instruktionen
│
├── server/               # Server-Backend (FastAPI + PJSIP)
│   ├── app/
│   │   ├── main.py       # FastAPI Einstiegspunkt, Event-Handler
│   │   ├── sip_client.py # PJSIP SIP-Client (eigener Thread!)
│   │   ├── ai_client.py  # OpenAI Realtime API WebSocket Client
│   │   ├── catalog.py    # Multi-Hersteller Produktkatalog
│   │   ├── order_manager.py  # Bestellverwaltung
│   │   ├── expert_client.py  # Expert-System für Fachfragen
│   │   ├── connection_manager.py  # WebSocket-Verbindungen
│   │   └── config.py     # Pydantic Settings
│   ├── system_katalog/   # Hersteller-Kataloge (JSON)
│   │   ├── _index.json   # Index aller Hersteller
│   │   ├── grohe.json
│   │   ├── villeroy_boch.json
│   │   ├── viega_sanpress.json
│   │   └── ...           # 63 Hersteller-Kataloge
│   ├── config/
│   │   ├── config.json   # Persistente Config (Instructions, Model)
│   │   └── instructions_new.json
│   ├── scraper/          # Katalog-Scraper für Heinrich Schmidt
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── requirements.txt
│
└── archiv/               # Archivierter Windows-Client (nicht mehr aktiv)
```

## Katalog-System (Multi-Hersteller)

### Datenstruktur

Die Katalog-Dateien (`server/system_katalog/*.json`) haben folgende Struktur:

```json
{
  "products": [
    {
      "Artikel": "WT+VERL80",           // Heinrich Schmidt Artikelnummer (INTERN)
      "Werksnummer": "4A128L01",         // Hersteller-Artikelnummer
      "Bezeichnung 1": "Smaragd Verity Line Waschtisch 80x50cm",
      "Bezeichnung 2": "1HL, m.UeL, weiss",
      "EK-Preis": "471,38",              // Einkaufspreis (Kundenpreis, Netto)
      "VK-Preis": "637,00",              // Verkaufspreis (Listenpreis)
      "EAN": "4051202573225",
      "ME": "Stück",                     // Mengeneinheit
      "PE": "1"                          // Packungseinheit
    }
  ],
  "metadata": {
    "total": 1981,
    "source": "Heinrich Schmidt OnlinePro (CSV Export)"
  }
}
```

### Normalisierte Produktstruktur (intern)

Die `catalog.py` normalisiert die Rohdaten in folgendes Format:

```python
{
    "artikel": "WT+VERL80",              # Heinrich Schmidt Bestellnummer
    "hersteller_nr": "4A128L01",         # Hersteller-Artikelnummer (Werksnummer)
    "bezeichnung": "Smaragd Verity Line Waschtisch 80x50cm 1HL, m.UeL, weiss",
    "ek_preis": 471.38,                  # Einkaufspreis (Float)
    "vk_preis": 637.00,                  # Verkaufspreis (Float)
    "ean": "4051202573225",
    "einheit": "Stück",
    "pe": "1",
    "hersteller_key": "villeroy_boch",
    "hersteller": "Villeroy Boch"
}
```

### Hersteller-Index

`server/system_katalog/_index.json` enthält die Übersicht aller Hersteller:

```json
{
  "total_products": 86404,
  "total_systems": 63,
  "systems": [
    {"name": "Grohe", "file": "grohe.json", "products": 1974},
    {"name": "Villeroy Boch", "file": "villeroy_boch.json", "products": 1981},
    ...
  ]
}
```

### Katalog-Funktionen (catalog.py)

| Funktion | Beschreibung |
|----------|--------------|
| `load_index()` | Lädt Hersteller-Index beim Start |
| `get_available_manufacturers()` | Liste aller Hersteller |
| `get_manufacturer_key(search)` | Findet Katalog-Key für Hersteller |
| `load_manufacturer_catalog(key)` | Lädt Katalog in Cache |
| `activate_catalog(key)` | Aktiviert Katalog für aktuelle Session |
| `get_catalog_for_ai(key)` | Formatiert Katalog für AI-Context |
| `search_products(query, ...)` | Sucht in aktiven Katalogen |
| `get_product_by_artikel(artikel)` | Findet Produkt nach HS-Artikelnummer |
| `get_product_by_hersteller_nr(nr)` | Findet Produkt nach Werksnummer |
| `clear_active_catalogs()` | Setzt aktive Kataloge zurück (bei Anruf-Ende) |

## AI Tools (Function Calling)

Die AI hat Zugriff auf folgende Funktionen:

| Tool | Beschreibung |
|------|--------------|
| `zeige_hersteller` | Zeigt alle verfügbaren Hersteller |
| `lade_hersteller_katalog` | Lädt Katalog eines Herstellers in AI-Context |
| `suche_produkt` | Sucht nach Produkten in geladenen Katalogen |
| `zeige_produkt_details` | Zeigt Details und Preise eines Produkts |
| `bestellung_hinzufuegen` | Fügt Produkt zur Bestellung hinzu |
| `zeige_bestellung` | Zeigt aktuelle Bestellung |
| `frage_experten` | Fragt Experten-Modell bei Fachfragen |

### AI-Workflow

1. **Hersteller ermitteln** - AI fragt Kunden oder nutzt `zeige_hersteller`
2. **Katalog laden** - AI ruft `lade_hersteller_katalog` auf
3. **Produkte finden** - AI hat alle Produkte im Context oder nutzt `suche_produkt`
4. **Details/Preise** - Bei Bedarf `zeige_produkt_details` für Preise
5. **Bestellen** - `bestellung_hinzufuegen` für jede Position

## Server-Komponenten

### SIP Client (`server/app/sip_client.py`)

- **PJSIP** C-Library mit Python Bindings
- Läuft in **separatem Thread** (KRITISCH! PJSIP ist nicht thread-safe)
- Kommunikation mit Main-Loop via `asyncio.Queue`
- Unterstützt **Opus Codec @ 48kHz** (viel bessere Qualität als G.711)
- Audio wird in 20ms Frames (960 Samples @ 48kHz = 1920 Bytes) verarbeitet

### AI Client (`server/app/ai_client.py`)

- **OpenAI Realtime API** via WebSocket (aiohttp)
- Endpoint: `wss://api.openai.com/v1/realtime?model=MODEL_NAME`
- Audio-Format: Input 16kHz PCM16, Output 24kHz PCM16
- Server-seitige VAD (Voice Activity Detection)
- **Function Calling** für Katalog-Funktionen

### Expert Client (`server/app/expert_client.py`)

Für komplexe Fachfragen kann die Realtime-AI einen "Kollegen" (Experten-Modell) fragen.

**Verfügbare Modelle (Stand Februar 2026):**

| Modell | Basis | Typ | Latenz |
|--------|-------|-----|--------|
| `gpt-5-mini` | GPT-5 | Standard | ~10s |
| `gpt-5-nano` | GPT-5 | Standard | ~24s |
| `gpt-5` | GPT-5 | Standard | ~27s |
| `gpt-5.2` | GPT-5 | Standard | ~30s |
| `o4-mini` | O-Serie | Reasoning | ~15s |
| `o3` | O-Serie | Reasoning | ~30s |
| `o3-pro` | O-Serie | Reasoning | ~45s |

**WICHTIG:** Nur GPT-5 und O-Serie Modelle verwenden - KEINE alten GPT-3/4 Modelle!

**Konfidenz-System:**
- Nur Antworten mit ≥90% Konfidenz werden an Kunden weitergegeben
- Bei niedriger Konfidenz: "Das kann ich leider nicht sicher beantworten"

### Order Manager (`server/app/order_manager.py`)

- In-Memory Bestellverwaltung
- Bestellung wird bei Anrufstart erstellt, bei Anrufende gelöscht
- Callback für GUI-Updates

## REST API Endpoints

| Endpoint | Methode | Beschreibung |
|----------|---------|--------------|
| `/` | GET | Health Check |
| `/status` | GET | Detaillierter Status (SIP, AI) |
| `/call/accept` | POST | Anruf manuell annehmen |
| `/call/hangup` | POST | Anruf beenden |
| `/ai/mute` | POST | AI stumm schalten |
| `/ai/unmute` | POST | Stummschaltung aufheben |
| `/instructions` | GET/POST | AI-Instruktionen lesen/setzen |
| `/model` | GET/POST | AI-Modell lesen/setzen |
| `/order` | GET/DELETE | Bestellung abrufen/löschen |
| `/expert/config` | GET/POST | Experten-Konfiguration |
| `/expert/models` | GET/POST | Experten-Modelle aktivieren/deaktivieren |
| `/expert/stats` | GET | Experten-Statistiken |
| `/ws` | WebSocket | Live-Updates |

## WebSocket Events

### Server → Client

```javascript
{ "type": "status", "sip_registered": true, "call_active": false }
{ "type": "call_incoming", "caller_id": "+4912345678" }
{ "type": "call_active", "caller_id": "+4912345678" }
{ "type": "call_ended", "reason": "hangup" }
{ "type": "transcript", "role": "caller|assistant", "text": "...", "is_final": true }
{ "type": "order_update", "order": { "items": [...], "caller_id": "..." } }
{ "type": "debug_event", "event": { "type": "...", "data": {...} } }
```

## Audio-Pipeline (KRITISCH!)

```
Telefon (48kHz Opus)
    ↓ PJSIP dekodiert
48kHz 16-bit PCM
    ↓ scipy.signal.resample
16kHz 16-bit PCM
    ↓ OpenAI Realtime API

OpenAI Realtime API
    ↓ 24kHz 16-bit PCM
scipy.signal.resample
    ↓ 48kHz 16-bit PCM
PJSIP enkodiert
    ↓ 48kHz Opus
Telefon
```

**Resampling-Code:**
```python
from scipy import signal as scipy_signal
import numpy as np

def resample_audio(audio_data: bytes, from_rate: int, to_rate: int) -> bytes:
    if from_rate == to_rate:
        return audio_data
    samples = np.frombuffer(audio_data, dtype=np.int16).astype(np.float32)
    num_samples = int(len(samples) * to_rate / from_rate)
    resampled = scipy_signal.resample(samples, num_samples)
    resampled = np.clip(resampled, -32768, 32767).astype(np.int16)
    return resampled.tobytes()
```

## Deployment

### Docker

```yaml
# docker-compose.yml
services:
  bestell-bot:
    build: .
    network_mode: host    # WICHTIG für SIP/RTP!
    privileged: true
    cap_add:
      - NET_ADMIN
      - NET_RAW
    volumes:
      - ./config:/app/config     # Persistente Config
      - ./recordings:/app/recordings
      - ./system_katalog:/app/system_katalog  # Katalog-Daten
    environment:
      - SIP_SERVER=sipconnect.sipgate.de
      - SIP_USER=xxx
      - SIP_PASSWORD=xxx
      - OPENAI_API_KEY=xxx
```

### PJSIP Build (im Dockerfile)

PJSIP muss aus Source gebaut werden mit Opus-Support:
- Version: 2.14.1
- Build-Deps: swig, libopus-dev, libspeex-dev
- **Null Sound Device** aktivieren (kein Hardware-Audio in Docker)

### Firewall-Ports

- **5060/UDP** - SIP Signaling
- **4000-4100/UDP** - RTP Media
- **8085/TCP** - API

## Wichtige Hinweise

### PJSIP Threading (KRITISCH!)

```
Assertion failed: "Calling pjlib from unknown/external thread"
```
→ PJSIP muss IMMER in einem dedizierten Thread laufen!

### Katalog-Caching

- Der Katalog-Index wird beim Serverstart geladen
- Einzelne Hersteller-Kataloge werden on-demand geladen und gecacht
- Aktive Kataloge werden bei Anruf-Ende zurückgesetzt
- Cache bleibt erhalten für schnelles erneutes Laden

### Artikelnummern-Format

- **Heinrich Schmidt Artikelnummer** (intern): z.B. `WT+VERL80`, `WC+VERLSRL`
- **Hersteller-Nummer** (Werksnummer): z.B. `4A128L01`, `4615R001`
- Die AI verwendet immer die Heinrich Schmidt Artikelnummer für Bestellungen!

### OpenAI Response Handling

- Server-VAD erkennt Sprach-Ende und triggert Response automatisch
- Bei aktiver Response KEIN manuelles `response.create` senden
- `response_in_progress` Flag tracken

### Barge-In / Interruption

Wenn User AI unterbricht:
1. Event `input_audio_buffer.speech_started` empfangen
2. Audio-Queue leeren: `sip_client.clear_audio_queue()`

## Troubleshooting

**WICHTIG:** Siehe `findings.md` für detaillierte Troubleshooting-Informationen!

Häufige Probleme:
1. **Audio verzerrt/schnell** → Sample-Rate Mismatch (siehe Audio-Pipeline)
2. **PJSIP Assertion Error** → Thread-Modell prüfen
3. **Keine RTP-Daten** → NAT/Firewall, `network_mode: host`
4. **AI antwortet nicht** → WebSocket-Verbindung, Session-Update prüfen
5. **Katalog nicht gefunden** → Prüfen ob Hersteller-Key korrekt ist

## GUI (Remote Control)

Die GUI (`gui/main.py`) verbindet sich zum Server und bietet:
- Live-Transkript
- Call-Status
- AI-Instruktionen bearbeiten
- Modell-Auswahl
- Bestellungsübersicht
- Debug-Log

```bash
# GUI starten
cd gui
python main.py --server http://10.200.200.1:8085
```

## Entwicklung

### Server lokal testen

```bash
cd server
docker-compose up --build
```

### Logs beobachten

```bash
docker-compose logs -f
```

## Server Deployment (WICHTIG!)

### IMMER via Git deployen!

**NIEMALS Dateien direkt via SCP auf den Server kopieren!**
Der Server hat ein Git-Repository unter `~/bestell-bot-voice`.
Deployment erfolgt IMMER über:
1. Lokaler Commit + Push
2. Git Pull auf dem Server
3. Docker Rebuild

### SSH-Zugang

```bash
ssh bot  # SSH-Alias für den Produktionsserver (10.200.200.1)
```

**ACHTUNG:** `ssh root@10.200.200.1` funktioniert NICHT (Port 22 blockiert).
Nutze IMMER den SSH-Alias `bot`.

### Deployment-Schritte (Standard-Workflow)

1. **Änderungen committen und pushen:**
```bash
git add <files>
git commit -m "feat: Beschreibung"
git push origin master
```

2. **Auf Server pullen:**
```bash
ssh bot "cd ~/bestell-bot-voice && git pull origin master"
```

Falls lokale Änderungen auf dem Server existieren:
```bash
ssh bot "cd ~/bestell-bot-voice && git checkout -- . && git pull origin master"
```

3. **Docker Container neu bauen und starten:**
```bash
ssh bot "docker stop bestell-bot-voice; docker rm bestell-bot-voice; cd ~/bestell-bot-voice/server && docker build -t server_bestell-bot . && docker run -d --name bestell-bot-voice --network host --env-file .env -v /home/nikolas/bestell-bot-voice/server/config:/app/config -v /home/nikolas/bestell-bot-voice/server/system_katalog:/app/system_katalog server_bestell-bot"
```

4. **Status prüfen:**
```bash
ssh bot "docker logs --tail 30 bestell-bot-voice"
ssh bot "curl -s http://localhost:8085/status"
```

### Einzeiler für komplettes Deployment

```bash
# Alles in einem Befehl (nach git push)
ssh bot "cd ~/bestell-bot-voice && git checkout -- . && git pull origin master && docker stop bestell-bot-voice; docker rm bestell-bot-voice; cd server && docker build -t server_bestell-bot . && docker run -d --name bestell-bot-voice --network host --env-file .env -v /home/nikolas/bestell-bot-voice/server/config:/app/config -v /home/nikolas/bestell-bot-voice/server/system_katalog:/app/system_katalog server_bestell-bot"
```

### Server-Pfade

| Pfad | Beschreibung |
|------|--------------|
| `~/bestell-bot-voice/` | Git Repository Root auf dem Server |
| `~/bestell-bot-voice/server/` | Server-Code |
| `~/bestell-bot-voice/server/.env` | Environment Variables |
| `/app/config/config.json` | Persistente Config (im Container) |
| `/app/system_katalog/` | Katalog-Dateien (im Container, gemountet) |
| `http://localhost:8085/` | API im Container |

### Wichtige Docker-Befehle auf dem Server

```bash
# Container Status
ssh bot "docker ps | grep bestell"

# Logs anzeigen (live)
ssh bot "docker logs -f bestell-bot-voice --tail 100"

# Container stoppen/entfernen
ssh bot "docker stop bestell-bot-voice; docker rm bestell-bot-voice"

# API Health Check
ssh bot "curl -s http://localhost:8085/status"

# Firewall Status prüfen
ssh bot "curl -s http://localhost:8085/firewall"
```

### SIP Firewall

Der Server hat eine IP-Whitelist für eingehende SIP-Anrufe:
- Nur sipgate IPs (217.10.0.0/16, 212.9.32.0/19, etc.) werden akzeptiert
- Anrufe von anderen IPs werden mit 403 Forbidden abgelehnt
- Firewall kann via GUI oder API ein/ausgeschaltet werden:
```bash
# Status abfragen
ssh bot "curl -s http://localhost:8085/firewall"

# Deaktivieren (alle IPs erlauben)
ssh bot "curl -X POST http://localhost:8085/firewall -H 'Content-Type: application/json' -d '{\"enabled\": false}'"

# Aktivieren
ssh bot "curl -X POST http://localhost:8085/firewall -H 'Content-Type: application/json' -d '{\"enabled\": true}'"
```

## Archivierter Code

Der `archiv/windows-client/` Ordner enthält den alten lokalen Windows-Client mit:
- pyVoIP (Python SIP Client)
- Lokale OpenAI Realtime Verbindung
- PySide6 UI

Dieser Code ist **nicht mehr aktiv**. Die gesamte Telefonie- und AI-Logik läuft jetzt auf dem Linux-Server.
