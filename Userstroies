Cursor Rules (POC, Python + Qt, Aircall SIP + Live-ChatGPT)
1) Zielbild & Scope (POC-first)

Primäres Ziel: Eingehenden Anruf via SIP (Aircall) annehmen, Audio in Echtzeit an eine ChatGPT Realtime/Streaming API senden, Antwort-Audio zurück zum Anrufer streamen, parallel Live-Transkript anzeigen.

POC = minimal: 1 Call gleichzeitig, keine Multi-Account-Administration, keine komplizierte Konfiguration, keine Datenbank.

Nicht-Ziele (für POC): Call Recording Archiv, CRM-Integration, Rollen/Rechte, Multi-Queue, Skalierung, Cloud-Deployment.

2) Architektur-Prinzipien

Event-driven: SIP Events und Audio-Frames laufen in separaten Threads/Tasks; UI bleibt immer responsiv.

Single responsibility: Klare Module:

sip/ (Call control + RTP Audio I/O)

realtime_ai/ (Streaming API Client, VAD/Turn-Handling)

transcription/ (ASR-In/Out, Anzeigenormierung)

ui/ (Qt Widgets, keine Business-Logik)

Schmaler “happy path” zuerst: incoming call → accept → stream → answer → hangup.

3) Technik-Entscheidungen (POC-friendly)

SIP/RTP: Nimm eine etablierte Library (z. B. pjsua2 / baresip binding / linphone SDK binding) statt “selbst RTP bauen”.

Audio pipeline: Intern ein einheitliches Format (z. B. 16kHz mono PCM) und klare Converter an den Rändern (SIP Codec ↔ PCM).

Streaming: Immer Chunk-basiert (20ms Frames), mit Ringbuffer.

Qt: PySide6 bevorzugt. UI-Updates nur über Qt-Signale/Slots.

4) Latenz-Regeln

“Fast path” gilt immer:

Keine blockierenden Netzwerkcalls im UI-Thread.

Keine großen Buffers (keep small, e.g. 100–300ms).

Audio-Frames sofort weiterreichen (producer/consumer queues).

Logging asynchron und sparsam; keine riesigen JSON dumps im hot path.

5) Sicherheits- & Datenschutz-Minimum (auch im POC)

Keine Secrets im Repo: API Keys via .env / OS keychain / env vars.

Default: keine Speicherung von Audio/Transkripten; nur Live-Anzeige.

“Kill switch”: Button/Hotkey „AI stumm“ / „Stop Streaming“.

6) Konfig & Setup

Eine einzige config.toml oder .env:

SIP user/pass/server

OpenAI API key + model

Audio settings

Startbar per: python main.py — ohne Installer.

7) Observability (POC-nützlich, nicht overkill)

Ein Debug-Panel in der UI:

Call state (RINGING/ACTIVE/ENDED)

RTT/Latency grob (ms)

Queue sizes (Audio in/out)

Last error

Logs: rotierend, Level via ENV.

8) Definition of Done (POC)

Eingehender Call kann angenommen werden.

Anrufer spricht → ChatGPT antwortet hörbar innerhalb “gefühlt” kurzer Zeit (Ziel: < 1–2s turn latency).

Live-Transkript zeigt:

“Caller” Text (Streaming)

“Assistant” Text (Streaming)

App crasht nicht beim Auflegen / erneuten Anruf.

9) Coding Standards

Type hints überall, ruff + black.

Keine abstrakten Frameworks, keine generischen “Enterprise”-Patterns.

Jede Komponente hat eine kleine Demo/Smoke-Test Funktion.

10) Risiken & Fallbacks (POC pragmatisch)

Wenn Full Duplex schwierig ist: zuerst Half-duplex (Push-to-talk / turn-based) als Fallback.

Wenn SIP Audio schwierig: zuerst Loopback-Mic/Speaker lokal testen, dann SIP dran.

User Stories (POC) – inkl. Akzeptanzkriterien
Epic 1: SIP Client + Call Handling (Aircall)

US1.1 – SIP Account konfigurieren

Als Nutzer möchte ich SIP Zugangsdaten (Server/User/Pass) eingeben, damit der Client sich registrieren kann.

Akzeptanzkriterien:

UI Feld für Server/User/Pass (oder config file).

Statusanzeige: Registered / Not Registered + Fehlermeldung.

US1.2 – Eingehenden Anruf anzeigen

Als Nutzer möchte ich bei einem eingehenden Call eine sichtbare Benachrichtigung in der App sehen, damit ich reagieren kann.

Akzeptanzkriterien:

UI zeigt Caller-ID/Nummer (falls vorhanden) und Call State Ringing.

Buttons: Annehmen, Ablehnen.

US1.3 – Anruf annehmen/ablehnen

Als Nutzer möchte ich den Call annehmen oder ablehnen können, um den Gesprächsfluss zu steuern.

Akzeptanzkriterien:

Annehmen setzt Call State Active und startet Audio I/O.

Ablehnen beendet Call und setzt State Ended.

US1.4 – Auflegen

Als Nutzer möchte ich jederzeit auflegen können, damit ich das Gespräch beenden kann.

Akzeptanzkriterien:

Hangup beendet Call zuverlässig.

Alle Streaming-Tasks werden sauber gestoppt (keine Zombie-Threads).

Epic 2: Realtime Audio Streaming zu ChatGPT + Antwort zurück

US2.1 – Audio vom Anrufer in Echtzeit erfassen

Als Nutzer möchte ich das eingehende Call-Audio in kleinen Frames verfügbar haben, damit es live verarbeitet werden kann.

Akzeptanzkriterien:

Kontinuierliche Audio-Frames im definierten Format (z. B. 16k PCM) liegen vor.

Keine UI-Freezes während Audio läuft.

US2.2 – Audio live an ChatGPT streamen

Als Nutzer möchte ich das Caller-Audio live an die ChatGPT Streaming API senden, damit ChatGPT mithören kann.

Akzeptanzkriterien:

Streaming-Session startet beim Call-Start.

Audio-Chunks werden fortlaufend gesendet.

Bei Network Error: sichtbarer Status + Retry/Stop.

US2.3 – ChatGPT Antwort-Audio in den Call zurück streamen

Als Nutzer möchte ich die Audio-Antwort von ChatGPT über den SIP Call ausgeben, damit der Anrufer sie hört.

Akzeptanzkriterien:

Sobald ChatGPT Audio liefert, wird es im Call hörbar.

Keine massiven Aussetzer/Knacken (POC akzeptiert “leicht”).

“Mute AI” stoppt Ausgabe sofort.

US2.4 – Turn-Handling / Unterbrechen

Als Nutzer möchte ich, dass der Assistent aufhört zu sprechen, wenn der Anrufer wieder anfängt, um natürlichere Dialoge zu haben.

Akzeptanzkriterien:

Bei Detektion von Caller-Speech (VAD oder Pegel): AI Audio wird gestoppt.

Danach kann wieder neu geantwortet werden.

Epic 3: Live-Transkription anzeigen

US3.1 – Live-Transkript des Anrufers

Als Nutzer möchte ich in der UI sehen, was der Anrufer gerade sagt, damit ich den Inhalt verfolgen kann.

Akzeptanzkriterien:

Streaming-Text (partial + final) wird angezeigt.

Finalisierte Segmente werden sauber zusammengeführt.

US3.2 – Live-Transkript des Assistenten

Als Nutzer möchte ich in der UI sehen, was ChatGPT antwortet (Text), damit ich die Antwort nachvollziehen kann.

Akzeptanzkriterien:

Parallel zur Audio-Ausgabe erscheint Text.

Markierung “Assistant” vs “Caller”.

US3.3 – Transkript exportieren (optional POC+)

Als Nutzer möchte ich das Transkript kopieren oder als Text speichern, um es weiterzuverwenden.

Akzeptanzkriterien:

Button Copy oder Save .txt.

Default: keine automatische Speicherung ohne Klick.

Epic 4: UI (Qt) für POC

US4.1 – Minimal Call Screen

Als Nutzer möchte ich eine simple Oberfläche mit Call-Controls und Transkript, damit ich den POC bedienen kann.

Akzeptanzkriterien:

Oben: Registration/Call State

Mitte: Transkript-Panel

Unten: Buttons (Accept/Reject/Hangup/Mute AI)

US4.2 – Debug/Status Panel

Als Entwickler möchte ich Latenz und Queue-Größen sehen, damit ich Performance-Probleme debuggen kann.

Akzeptanzkriterien:

Anzeige von: estimated latency, audio queue depth, last error.

Epic 5: Stabilität & Fehlerfälle

US5.1 – Reconnect SIP Registration

Als Nutzer möchte ich, dass die App bei kurzfristigen Netzwerkproblemen automatisch neu registriert, damit sie weiter erreichbar bleibt.

Akzeptanzkriterien:

Bei Disconnect: Status Reconnecting…

Nach Erfolg: Registered

US5.2 – Sauberes Shutdown

Als Nutzer möchte ich die App schließen können, ohne dass Audio/Threads hängen bleiben.

Akzeptanzkriterien:

App Exit beendet alle Tasks innerhalb kurzer Zeit.

Keine Exceptions im Shutdown-Pfad.

Wenn du willst, schreibe ich dir als nächsten Schritt ein sehr simples POC-Backlog (Sprint 0/1) und eine Ordnerstruktur + Interfaces (z. B. CallController, AudioBridge, RealtimeClient, Qt Signals) – weiterhin komplett “keep it simple”.